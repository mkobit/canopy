# Sync

> Status: **draft**
> Scope: event replication, sync protocol, transport adapters, conflict handling, offline-first model
> Depends on: [2026-02-06-core-data-model.md](2026-02-06-core-data-model.md), [2026-02-08-event-system.md](2026-02-08-event-system.md)

---

## 1. Principles

Sync is event replication.
Every device should eventually have every event.
That is the entire requirement.

The sync layer does not interpret events.
It does not resolve conflicts, apply projection, or understand the graph model.
It moves events between devices and deduplicates by EventId.

Conflict resolution and projection happen after sync, in the event system and projection layers.
The sync layer is transport: reliable, eventually-consistent delivery of events.

---

## 2. What sync must do

The sync layer has four responsibilities:

1. **Replicate events**: transfer events from one device to another so that every device eventually has every event.
2. **Deduplicate**: recognize that events with the same EventId are the same event, regardless of how many sources deliver them.
3. **Work offline**: events created while offline are stored locally and synced when connectivity is available.
4. **Be transport-agnostic**: different deployment scenarios use different transports. The sync layer adapts.

The sync layer does not:

- Order events (ordering is by UUIDv7 timestamp, determined at event creation).
- Resolve conflicts (resolution is timestamp-based LWW, applied during projection).
- Validate events (validation happens before insertion into the local log).
- Understand event semantics (it treats events as opaque payloads keyed by EventId).

---

## 3. Sync model

### Events as a replicated set

The event log is logically a **set of events keyed by EventId**.
Sync is set reconciliation: each device computes which events the other is missing and transfers them.

This model has useful properties:

- **Idempotent**: receiving the same event twice has no effect (deduplicated by EventId).
- **Order-independent**: events can arrive in any order. The projection layer sorts by UUIDv7 timestamp before applying.
- **Append-only**: events are never modified or deleted during sync. Only new events are added.

### Sync flow

When two devices sync:

1. Device A advertises which EventIds it has (or a compact summary like a hash or watermark).
2. Device B computes which events it has that A does not.
3. Device B sends the missing events to A.
4. A validates each received event and appends it to its local log.
5. A re-projects the graph from the updated log (or incrementally applies the new events).
6. The process runs in both directions (A also sends events B is missing).

### Batch completeness

Events with a shared batchId must all arrive before projection processes any of them.
The sync layer buffers batch-incomplete event sets until all events in the batch are received.

If a batch remains incomplete after sync (partial transfer, interrupted connection), the buffered events are held and retried on the next sync cycle.
They do not enter the local log until the batch is complete.

---

## 4. Transport adapters

The sync protocol is independent of the transport mechanism.
Different deployments use different transports.

### File-based sync

Events are stored as files in a synced folder (e.g., Google Drive, Dropbox, or any filesystem sync tool).
Each event is a file (or events are batched into append-only log files).
The sync mechanism is the filesystem sync itself.

How this works:

- Each device writes new events as files to a shared folder.
- The filesystem sync tool replicates files to other devices.
- Each device scans the folder for events it hasn't processed yet.
- Deduplication is by EventId (not filename).

This is the simplest transport and requires no hosted infrastructure.
It works for single-user-multi-device scenarios.
Users do not need to pay for or maintain sync services.

Considerations:

- File conflicts (two devices write to the same file simultaneously) are avoided by using unique filenames per event or per write session.
- Append-only log files may conflict if two devices append simultaneously; individual event files avoid this.
- Scanning a large folder for new events can be slow; an index file or watermark can optimize this.

### WebSocket / real-time

A WebSocket connection between devices (or between devices and a relay server).
Events are pushed in real-time as they are created.
Set reconciliation happens on connection establishment; incremental push happens during the session.

This is the model for real-time multi-device use when a relay server is available.

### HTTP API

A pull-based model where devices poll a server for new events.
The server stores events and serves them on request.
Devices push new events to the server.

This is the model for cloud-hosted sync services.

### LAN / peer-to-peer

Direct device-to-device sync over a local network.
No server required.
Useful for home setups or offline environments.

### Adapter interface

All transports implement a common interface:

- **Push events**: send events to the remote.
- **Pull events**: request events from the remote that the local device is missing.
- **Advertise state**: send a summary of which events the local device has.
- **Receive state**: receive a summary of which events the remote device has.

The exact wire format and protocol details are transport-specific.
The sync engine interacts with all transports through this interface.

---

## 5. Offline-first

The system is offline-first by default.
The local event log is always available for reads and writes, regardless of connectivity.

When offline:

- New events are created and appended to the local log normally.
- Projection updates the local materialized graph.
- The user experience is unaffected.

When connectivity is restored:

- The sync layer exchanges events with remote devices or servers.
- New remote events are validated and appended to the local log.
- The projection re-processes to incorporate remote events.
- Conflict resolution (LWW per property) applies if remote events conflict with local ones.

The user may see their graph state change after sync if remote events override local values.
This is expected behavior, not an error.

---

## 6. Conflict handling during sync

The sync layer itself does not resolve conflicts.
It delivers events; the projection layer resolves conflicts.

However, the sync layer can **detect** potential conflicts for UX purposes:

- If a received event updates a property that was also updated locally since the last sync, that is a potential conflict.
- The sync layer can flag these events so the application can surface them to the user ("this property was changed on another device").

Whether to surface conflicts is a UX decision, not a sync layer decision.
The data model supports it: the event log contains both the local and remote events, and the projection deterministically chose one.
The user can inspect the event history to see what was overridden.

---

## 7. No dependency on CRDT libraries

The sync model does not depend on a CRDT library (such as Yjs).
Event replication is a simpler problem than CRDT-based collaborative data structures.

The system does not use:

- Yjs Y.Doc, Y.Map, Y.Array, or Y.Text for data storage.
- CRDT merge functions for conflict resolution.
- CRDT-specific wire protocols.

Conflict resolution is timestamp-based last-write-wins, applied during projection.
Event deduplication is by EventId.
Event ordering is by UUIDv7 timestamp with device ID tiebreaker.

These are simple, well-understood mechanisms that do not require a CRDT framework.

If a future requirement (e.g., real-time collaborative text editing) demands character-level CRDT, that can be introduced as a scoped addition without changing the core sync model.

---

## 8. Security and trust

### Event authenticity

Events received during sync must be validated before entering the local log.
Validation includes structural checks, type conformance, and namespace rules (see event system doc, section 6).

> **Open question**: whether events should carry cryptographic signatures for authenticity.
> This would allow a device to verify that an event was produced by an authorized device/user.
> Signing adds complexity but is important for multi-user or untrusted transport scenarios.

### Transport encryption

Transports should use encryption in transit (TLS for WebSocket/HTTP, encrypted filesystem sync).
This is a transport concern, not a sync protocol concern.

### Event privacy

The event log may contain sensitive data.
Transports must not expose event payloads to unauthorized parties.
End-to-end encryption (events encrypted before leaving the device, decrypted only by authorized devices) is desirable for untrusted transports.

> **Open question**: encryption model for events at rest and in transit.

---

## 9. What this document does not cover

| Concern                                | Where it belongs                 |
| -------------------------------------- | -------------------------------- |
| Event validation rules                 | Event system                     |
| Conflict resolution (LWW, delete-wins) | Event system                     |
| Storage engine persistence             | Storage layer design             |
| Real-time collaborative text editing   | Future extension (if ever)       |
| Multi-user access control              | Extension and execution model    |
| Specific wire protocol formats         | Transport adapter implementation |

---

## 10. Open questions

1. File-based sync format: individual event files vs append-only log files vs hybrid.
2. Set reconciliation protocol: full EventId exchange vs bloom filters vs vector clocks vs watermarks.
3. Batch completeness guarantees across transports with unreliable delivery.
4. Cryptographic event signing for authenticity in multi-user scenarios.
5. End-to-end encryption model for events.
6. Whether the sync layer should detect and flag potential conflicts for UX surfacing.
7. How to handle sync with very large event logs (initial sync of a mature vault to a new device).
8. Whether to support selective sync (sync only certain namespaces or node types).
