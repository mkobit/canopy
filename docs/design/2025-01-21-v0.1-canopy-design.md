# Canopy: A Graph-Native Personal Knowledge Management System

## Design Document v0.1

**Status:** Foundation Design Phase
**Last Updated:** 2025-01-21

---

## 1. Motivation and Principles

Canopy is a graph-native personal knowledge management system that fundamentally reimagines how knowledge is structured, queried, and rendered. Unlike file-based systems (Obsidian, Logseq) that treat documents as atomic units with embedded links, Canopy implements an "everything is a node" architecture where all content—including type definitions, queries, views, and rendering templates—exists as nodes within the graph database itself.

### 1.1 Core Principles

**Graph-First Data Model.** Content is modeled as nodes and edges in a property graph, not as files with embedded links. A "note" is not a file—it is a view over related content nodes connected by edges. This enables true transclusion, granular synchronization, and semantic relationships between content units.

**Meta-Circularity.** The system can introspect and modify its own schema. Type definitions, query definitions, view templates, and workflow configurations all exist as nodes in the graph. Users create custom types by creating NodeType nodes. The system queries its own structure to determine rendering behavior.

**Event Sourcing.** Events are the source of truth; graph state is a projection. Every mutation produces an immutable event. The current graph state can be reconstructed by replaying events. This provides audit trails, enables CRDT-based synchronization, and cleanly separates "what happened" from "current state."

**View-Based Rendering.** How content appears is determined by query + template nodes, not by properties on content nodes themselves. The same data can be rendered multiple ways. Rendering logic lives in the graph as ViewDefinition nodes, enabling user customization and extension.

**Functional Core.** The graph is the aggregate root. All mutations flow through pure functions that return new state. Side effects (persistence, sync, UI) occur only at boundaries. No throw/catch—Result types throughout.

### 1.2 Design Influences

- **Kythe:** Typed relationships, anchor patterns, definition vs. reference distinction
- **Schema.org:** Vocabulary patterns for common domains
- **Beancount:** Plain-text source of truth, functional core, rigorous data model
- **Notion/Roam:** Blocks as first-class entities (but with true graph semantics)
- **CRDTs:** Conflict-free synchronization primitives

---

## 2. Data Model

### 2.1 Fundamental Entities

The data model consists of three primitive concepts:

```
Node    := { id: NodeId, type: NodeTypeId, properties: Properties }
Edge    := { id: EdgeId, type: EdgeTypeId, source: NodeId, target: NodeId, properties: Properties }
Graph   := { nodes: Map<NodeId, Node>, edges: Map<EdgeId, Edge> }
```

Both nodes and edges are first-class entities with independent identity. Edges are not mere pointers—they have their own UUIDs, types, and properties.

### 2.2 Identity Model

All entities use **UUIDv7** identifiers:
- Time-ordered (lexicographic sorting = chronological sorting)
- Globally unique (no coordination required for ID generation)
- 128-bit (sufficient entropy for all practical purposes)

```typescript
type NodeId = Brand<string, 'NodeId'>  // UUIDv7
type EdgeId = Brand<string, 'EdgeId'>  // UUIDv7
```

Edges have independent identity because:
- Multiple edges of the same type can exist between the same nodes (e.g., "read book" twice with different dates)
- Edge properties store relationship-specific data (the date belongs to the reading event, not the person or book)
- Edges can be queried, versioned, and referenced independently

### 2.3 Properties

Properties are typed key-value pairs on nodes and edges:

```typescript
type PropertyValue =
  | string
  | number
  | boolean
  | Date
  | NodeId           // Reference to another node
  | PropertyValue[]  // Homogeneous arrays
  | null

type Properties = Map<PropertyKey, PropertyValue>
```

Property schemas are defined by NodeType and EdgeType nodes (see Section 5).

### 2.4 The Graph as Aggregate Root

The Graph is the single aggregate root for all mutations:

```typescript
interface Graph {
  readonly nodes: ReadonlyMap<NodeId, Node>
  readonly edges: ReadonlyMap<EdgeId, Edge>
}

function applyEvent(graph: Graph, event: GraphEvent): Result<Graph, GraphError>
```

All operations that modify state:
1. Accept the current graph
2. Return a new graph (or error)
3. Never mutate the input

Side effects (persistence, sync, UI) occur at the boundary after the pure core computation completes.

---

## 3. Content Model

### 3.1 Blocks as Nodes

Content is modeled as a graph of block nodes, not as documents with embedded structure. A TextBlock, CodeBlock, or HeadingBlock is a node. Containment is expressed through `child_of` edges with position properties.

```
TextBlock[intro-001] {
  type: "TextBlock",
  content: [
    { type: 'text', value: 'Async I/O enables ' },
    { type: 'bold', value: 'concurrent operations' },
    { type: 'text', value: ' without blocking.' }
  ]
}

CodeBlock[example-001] {
  type: "CodeBlock",
  language: "python",
  content: "async def fetch(url):\n    ..."
}

// Containment via edges
TextBlock[intro-001] --child_of { position: "a0" }--> Concept[AsyncIO]
CodeBlock[example-001] --child_of { position: "a1" }--> Concept[AsyncIO]
```

### 3.2 Rich Text Representation

Text content uses structured content arrays rather than inline nodes:

```typescript
type TextContent = ContentSegment[]

type ContentSegment =
  | { type: 'text', value: string }
  | { type: 'bold', value: string }
  | { type: 'italic', value: string }
  | { type: 'code', value: string }
  | { type: 'link', target: NodeId, display: string }
  | { type: 'wikilink', target: NodeId, alias?: string }
```

Node-level modeling is reserved for semantic units (paragraphs, blocks). Character-level styling remains within the content array. This balances granularity with practical performance.

### 3.3 WikiLinks

WikiLinks reference nodes by UUID with optional display alias:

```
[[uuid:concept-async-io|Async I/O]]
```

Resolution: The system looks up the target NodeId. If the node exists, the link resolves. If not, it's a dangling reference (tracked but not blocking).

### 3.4 Ordering: Fractional Indexing

Block ordering uses fractional indexing on the `position` property of `child_of` edges:

```
Position examples:
  "a0" < "a1" < "a2"
  Insert between a1 and a2: "a1V" (midpoint)

CRDT-friendly: insertions never conflict with existing positions
```

This enables concurrent editing—two users can insert blocks without coordination, and positions always have a well-defined order.

### 3.5 What is a "Note"?

A note is not a thing—it's a view over related content nodes:

```
"Async I/O Guide" rendered view =
  Query: MATCH (b)-[:child_of]->(n:Concept {name: "Async I/O"})
         RETURN b ORDER BY b.position
  Template: markdown-linear
  Result: Rendered content blocks in order
```

The same content blocks can appear in multiple views. Editing a block updates it everywhere it appears.

---

## 4. Event Model

### 4.1 Event Types

All mutations produce events. Events are immutable records of what happened:

```typescript
type GraphEvent =
  // Node lifecycle
  | { type: 'NodeCreated', id: NodeId, nodeType: NodeTypeId, properties: Properties, timestamp: Instant }
  | { type: 'NodePropertiesUpdated', id: NodeId, changes: PropertyChanges, timestamp: Instant }
  | { type: 'NodeDeleted', id: NodeId, timestamp: Instant }

  // Edge lifecycle
  | { type: 'EdgeCreated', id: EdgeId, edgeType: EdgeTypeId, source: NodeId, target: NodeId, properties: Properties, timestamp: Instant }
  | { type: 'EdgePropertiesUpdated', id: EdgeId, changes: PropertyChanges, timestamp: Instant }
  | { type: 'EdgeDeleted', id: EdgeId, timestamp: Instant }

  // Workflow events
  | { type: 'WorkflowStarted', workflowId: NodeId, targetId: NodeId, timestamp: Instant }
  | { type: 'WorkflowStepCompleted', workflowId: NodeId, step: string, result: any, timestamp: Instant }
  | { type: 'WorkflowFailed', workflowId: NodeId, step: string, error: string, timestamp: Instant }
  | { type: 'WorkflowCompleted', workflowId: NodeId, timestamp: Instant }

type Instant = Brand<number, 'Instant'>  // Milliseconds since epoch, aligns with TC39 Temporal
```

### 4.2 Graph Projection

The current graph state is computed by projecting events:

```typescript
function projectGraph(events: GraphEvent[]): Graph {
  return events.reduce(applyEvent, emptyGraph)
}
```

This provides:
- **Audit trail:** Complete history of all changes
- **Time travel:** Reconstruct graph at any point in time
- **CRDT merge:** Events from multiple devices merge; graph recomputes
- **Soft delete:** Delete events don't destroy data; filtering events = undo

### 4.3 Event Storage

Events are stored in a Yjs shared array. Each device appends events locally. Yjs handles synchronization and conflict-free merging of the event log.

```
Device A: [e1, e2, e3]
Device B: [e1, e2, e4]
Merged:   [e1, e2, e3, e4]  // Order determined by Yjs + UUIDv7 timestamps
```

The graph is recomputed locally from the merged event stream.

---

## 5. Schema System

### 5.1 Three-Tier Hierarchy

```
┌─────────────────────────────────────────────┐
│  MetaTypes (immutable, define the system)   │
│  NodeType, EdgeType, PropertyType           │
├─────────────────────────────────────────────┤
│  SystemTypes (versioned, migrated)          │
│  TextBlock, CodeBlock, Concept, Project...  │
├─────────────────────────────────────────────┤
│  UserTypes (mutable, per-graph)             │
│  Custom types created by users              │
└─────────────────────────────────────────────┘
```

### 5.2 MetaTypes

MetaTypes define what types look like. They are hardcoded in the application (not stored as nodes):

```typescript
// NodeType is a MetaType - defines what node types look like
interface NodeTypeDefinition {
  id: NodeTypeId
  name: string
  properties: PropertyDefinition[]
  requiredProperties: PropertyKey[]
  validOutgoingEdges: EdgeTypeId[]
  validIncomingEdges: EdgeTypeId[]
}

// EdgeType is a MetaType - defines what edge types look like
interface EdgeTypeDefinition {
  id: EdgeTypeId
  name: string
  sourceTypes: NodeTypeId[]
  targetTypes: NodeTypeId[]
  properties: PropertyDefinition[]
  transitive: boolean
  symmetric: boolean
  inverse?: EdgeTypeId
}
```

### 5.3 SystemTypes

SystemTypes are provided by the application and stored as nodes in the graph:

```
NodeType[TextBlock] {
  id: "system:nodetype:text-block",
  name: "TextBlock",
  properties: [
    { name: "content", type: "content-array", required: true }
  ]
}

NodeType[CodeBlock] {
  id: "system:nodetype:code-block",
  name: "CodeBlock",
  properties: [
    { name: "content", type: "string", required: true },
    { name: "language", type: "string", required: false }
  ]
}

NodeType[Concept] {
  id: "system:nodetype:concept",
  name: "Concept",
  properties: [
    { name: "name", type: "string", required: true },
    { name: "maturity", type: "string", required: false },
    { name: "confidence", type: "number", required: false }
  ]
}

EdgeType[child_of] {
  id: "system:edgetype:child-of",
  name: "child_of",
  properties: [
    { name: "position", type: "string", required: true }
  ]
}
```

### 5.4 UserTypes

Users create custom types by creating NodeType/EdgeType nodes:

```
NodeType[Recipe] {
  id: "user:nodetype:recipe",
  name: "Recipe",
  properties: [
    { name: "name", type: "string", required: true },
    { name: "servings", type: "number", required: false },
    { name: "prepTime", type: "number", required: false }
  ]
}
```

### 5.5 Structural Typing

Validation uses structural typing:
- A node conforms if it has all required properties with correct types
- Extra properties are allowed (open-world assumption)
- Missing optional properties are fine
- Validation errors are warnings, not blockers

```typescript
function validateNode(node: Node, nodeType: NodeTypeDefinition): ValidationResult {
  // Check required properties exist and have correct types
  // Return warnings for issues, not errors that block saving
}
```

---

## 6. View System

### 6.1 View-Based Rendering Architecture

Nodes do not have a `renderer` property. Rendering is determined by:

1. Query settings node for the node type
2. Look up the ViewDefinition node for that type
3. ViewDefinition may reference WASM module or system renderer

```
Settings[rendering] {
  id: "settings:rendering",
  mappings: {
    "system:nodetype:text-block": "view:text-block-default",
    "system:nodetype:code-block": "view:code-block-default",
    "system:nodetype:markdown": "view:markdown-default"
  }
}

ViewDefinition[markdown-default] {
  id: "view:markdown-default",
  nodeType: "system:nodetype:markdown",
  renderer: "system:markdown-renderer",  // Built-in system renderer
  options: {
    syntaxHighlighting: true,
    mathSupport: true
  }
}
```

### 6.2 MarkdownNode and System Renderers

MarkdownNode is a content node type with a system-provided view renderer:

```
NodeType[MarkdownNode] {
  id: "system:nodetype:markdown",
  name: "MarkdownNode",
  properties: [
    { name: "content", type: "string", required: true }
  ]
}

ViewDefinition[markdown-default] {
  id: "view:markdown-default",
  nodeType: "system:nodetype:markdown",
  renderer: "system:markdown-renderer",
  // System-provided, renders markdown to HTML
  // Supports live preview while typing
}
```

The markdown renderer is a system built-in that:
- Parses markdown content
- Resolves wikilinks to node UUIDs
- Renders to HTML/React components
- Supports live preview during editing

### 6.3 Renderer Flavoring

System renderers can be "flavored" by user ViewDefinitions:

```
ViewDefinition[markdown-academic] {
  id: "view:markdown-academic",
  extends: "view:markdown-default",
  options: {
    citationStyle: "apa",
    footnoteRendering: "sidenotes"
  }
}
```

Users can create entirely custom renderers via WASM:

```
ViewDefinition[custom-chart] {
  id: "view:custom-chart",
  nodeType: "user:nodetype:chart-data",
  renderer: "wasm:user-chart-renderer",
  wasmModule: "node:user-wasm-chart-001"
}
```

### 6.4 Settings Resolution

Rendering settings resolve through a chain:

```
1. Node-specific override (rare)
2. User settings node
3. System settings node (defaults)

function resolveViewDefinition(nodeType: NodeTypeId): ViewDefinition {
  const userMapping = querySettings('user:settings:rendering', nodeType)
  if (userMapping) return getNode(userMapping)

  const systemMapping = querySettings('system:settings:rendering', nodeType)
  return getNode(systemMapping)
}
```

### 6.5 Rendering Pipeline

```
1. Determine node type
2. Look up ViewDefinition via settings
3. Load renderer (system built-in or WASM)
4. Query child nodes (for container types)
5. Recursively render children
6. Compose final output
```

For container nodes (notes composed of blocks):

```typescript
function renderContainer(node: Node, graph: Graph): RenderedOutput {
  const children = query(graph, `
    MATCH (child)-[:child_of]->(parent {id: $nodeId})
    RETURN child ORDER BY child.position
  `, { nodeId: node.id })

  return children.map(child => {
    const viewDef = resolveViewDefinition(child.type)
    const renderer = loadRenderer(viewDef)
    return renderer.render(child, graph)
  })
}
```

---

## 7. Query Layer

### 7.1 Query Strategy

**Short-term:** Cypher (Neo4j-compatible syntax)
**Long-term:** ISO GQL (when ecosystem matures, estimated 2027-2028)

Query definitions are nodes:

```
Query[active-projects] {
  id: "query:active-projects",
  language: "cypher",
  query: "MATCH (p:Project {status: 'active'}) RETURN p ORDER BY p.priority DESC",
  parameters: []
}
```

### 7.2 Query Abstraction

```typescript
interface QueryEngine {
  execute<T>(query: Query, params: Record<string, unknown>): Result<T[], QueryError>
  validate(query: Query): ValidationResult
}

// Current implementation
class CypherQueryEngine implements QueryEngine { /* ... */ }

// Future implementation
class ISOGQLQueryEngine implements QueryEngine { /* ... */ }
```

Query nodes store the query string. When ISO GQL is ready, either:
- Automated translation of stored queries
- Dual storage during migration period

### 7.3 Embedded Queries

Queries can be embedded in content and render dynamically:

```markdown
## Active Projects

{{query:active-projects | view:project-cards}}
```

The query executes, results pass through the specified view template, and output renders inline.

---

## 8. Workflow System

### 8.1 Processing Model

"Unprocessed" is not a boolean property—it's determined by graph topology:

```
Raw entry node: No outgoing edges (except system edges like child_of)
Processed node: Has edges to Workflow execution nodes, generated outputs
```

Query for unprocessed items:

```cypher
MATCH (n:InboxItem)
WHERE NOT EXISTS {
  MATCH (n)-[e]->()
  WHERE NOT e.type IN ['child_of', 'system:*']
}
RETURN n
```

### 8.2 Workflow Definition

Workflows are nodes that define processing pipelines:

```
Workflow[process-bookmark] {
  id: "workflow:process-bookmark",
  trigger: "manual",  // or "on-create", "scheduled"
  steps: [
    { name: "extract-metadata", action: "system:extract-url-metadata" },
    { name: "summarize", action: "wasm:user-summarizer" },
    { name: "categorize", action: "system:auto-tag" }
  ]
}
```

### 8.3 Workflow Events

Workflow execution produces events:

```
WorkflowStarted { workflowId, targetId, timestamp }
WorkflowStepCompleted { workflowId, step: "extract-metadata", result, timestamp }
WorkflowStepCompleted { workflowId, step: "summarize", result, timestamp }
WorkflowFailed { workflowId, step: "categorize", error, timestamp }
```

Failed workflows are visible in the graph. Retry is possible by emitting new WorkflowStarted event.

---

## 9. Synchronization

### 9.1 CRDT Strategy

Yjs manages the event log, not the graph state:

```
┌─────────────┐     ┌─────────────┐
│  Device A   │     │  Device B   │
│  ┌───────┐  │     │  ┌───────┐  │
│  │Events │◄─┼─────┼─►│Events │  │  Yjs syncs event arrays
│  └───┬───┘  │     │  └───┬───┘  │
│      │      │     │      │      │
│      ▼      │     │      ▼      │
│  ┌───────┐  │     │  ┌───────┐  │
│  │ Graph │  │     │  │ Graph │  │  Graph computed locally
│  └───────┘  │     │  └───────┘  │
└─────────────┘     └─────────────┘
```

Each device:
1. Appends events to local Yjs array
2. Yjs syncs arrays across devices (conflict-free)
3. Each device recomputes graph from merged events

### 9.2 Conflict Resolution

UUIDv7 timestamps provide causal ordering. When events from different devices affect the same entity:

- Both events are applied in timestamp order
- Last-write-wins for property conflicts
- Edge creation is additive (both edges exist)

For node deletion conflicts:
- Delete is a tombstone event
- Subsequent events on deleted node are no-ops
- Can "undelete" by filtering out delete event (admin operation)

### 9.3 Offline Support

Full offline capability:
1. Events generated locally and stored
2. Graph projected locally
3. When online, Yjs syncs event logs
4. Graph recomputes with merged events

---

## 10. Extension API

### 10.1 External API: GraphQL

```graphql
type Query {
  node(id: ID!): Node
  nodes(type: String, filter: NodeFilter): [Node!]!
  edges(type: String, source: ID, target: ID): [Edge!]!
  query(cypher: String!, params: JSON): QueryResult
}

type Mutation {
  createNode(type: String!, properties: JSON!): Node!
  updateNode(id: ID!, properties: JSON!): Node!
  deleteNode(id: ID!): Boolean!
  createEdge(type: String!, source: ID!, target: ID!, properties: JSON): Edge!
}

type Subscription {
  nodeChanged(id: ID): NodeChangeEvent
  graphChanged: GraphChangeEvent
}
```

Access via HTTP or Unix socket for local automation.

### 10.2 Embedded Extensions: WASM

Users can compile custom logic to WASM:

```
WasmModule[custom-renderer] {
  id: "wasm:custom-renderer",
  binary: <base64-encoded-wasm>,
  exports: ["render"],
  permissions: ["read-graph"]
}
```

WASM modules:
- Run sandboxed (no filesystem, network access by default)
- Receive graph data through defined interface
- Return structured output (HTML, JSON, etc.)

### 10.3 Future: Embedded Scripting

Potential future addition: QuickJS or similar for lightweight scripting without compilation. Not in initial scope.

---

## 11. Storage Layer

### 11.1 Backend Abstraction

```typescript
interface StorageBackend {
  // Event log persistence
  appendEvents(events: GraphEvent[]): Promise<Result<void, StorageError>>
  loadEvents(since?: Instant): Promise<Result<GraphEvent[], StorageError>>

  // Snapshot for fast startup (optional optimization)
  saveSnapshot(graph: Graph, atEvent: EventId): Promise<Result<void, StorageError>>
  loadSnapshot(): Promise<Result<{graph: Graph, eventId: EventId} | null, StorageError>>
}
```

### 11.2 Initial Implementation

SQLite for local storage:
- Events table (append-only)
- Snapshots table (periodic graph snapshots for fast startup)
- Works in browser (sql.js), desktop (better-sqlite3), mobile

```sql
CREATE TABLE events (
  id TEXT PRIMARY KEY,      -- UUIDv7
  timestamp INTEGER,        -- Instant
  type TEXT,
  payload TEXT              -- JSON
);

CREATE TABLE snapshots (
  id TEXT PRIMARY KEY,
  event_id TEXT,            -- Snapshot is valid up to this event
  graph_data BLOB           -- Serialized graph
);
```

### 11.3 Cloud Sync

Pluggable cloud backends:
- Google Drive (JSON files)
- S3/compatible (for larger deployments)
- Custom sync server (Yjs websocket)

The event log syncs; graph computes locally.

---

## 12. Migration and Versioning

### 12.1 Schema Versioning

System schemas are versioned:

```typescript
const SCHEMA_VERSION = "0.1.0"

interface SchemaMigration {
  fromVersion: string
  toVersion: string
  migrate: (events: GraphEvent[]) => GraphEvent[]
}
```

### 12.2 Migration via Event Replay

When schema changes:
1. Load all events
2. Apply migration transform to events
3. Reproject graph from migrated events
4. Save migrated events

This handles:
- Property renames
- Type splits/merges
- Structural changes

### 12.3 Soft Delete

Event sourcing provides natural soft delete:
- NodeDeleted event marks node as deleted
- Filtering out delete events = "undelete"
- Historical queries can include deleted nodes

---

## 13. Technology Choices Summary

| Component | Choice | Rationale |
|-----------|--------|-----------|
| Language | TypeScript | Fast iteration, ecosystem, type safety |
| Query | Cypher → ISO GQL | Production-ready now, standard future |
| CRDT | Yjs | Proven, well-documented, active development |
| Validation | Zod | Runtime type checking, schema generation |
| Storage | SQLite | Cross-platform, embedded, reliable |
| IDs | UUIDv7 | Time-ordered, globally unique, standard |
| Timestamps | Instant (ms since epoch) | TC39 Temporal alignment |

---

## 14. Development Phases

### Phase 1: Foundation (Months 1-2)
- Core data model (Node, Edge, Graph)
- Event system (GraphEvent types, projection)
- Basic storage (SQLite)
- Type system (NodeType, EdgeType nodes)

### Phase 2: Content (Months 2-3)
- Block node types (TextBlock, CodeBlock, MarkdownNode)
- child_of edges with fractional indexing
- Basic rendering pipeline
- Markdown system renderer

### Phase 3: Query & Views (Months 3-4)
- Cypher query engine integration
- Query nodes and embedded queries
- ViewDefinition nodes
- Settings resolution

### Phase 4: Sync (Months 4-5)
- Yjs integration for event log
- Multi-device synchronization
- Conflict resolution
- Offline support

### Phase 5: Extension (Months 5-6)
- GraphQL API
- WASM renderer support
- Custom type creation UI
- Workflow system

---

## Appendix A: Example Graph

```
# Concept with content blocks
Concept[AsyncIO] {
  id: "node:concept-async-io",
  type: "system:nodetype:concept",
  name: "Async I/O",
  maturity: "evergreen",
  confidence: 0.9
}

MarkdownNode[async-intro] {
  id: "node:md-async-intro",
  type: "system:nodetype:markdown",
  content: "# Understanding Async I/O\n\nAsync I/O enables **concurrent operations**..."
}

CodeBlock[async-example] {
  id: "node:code-async-example",
  type: "system:nodetype:code-block",
  language: "python",
  content: "async def fetch(url):\n    async with aiohttp.ClientSession() as session:\n        return await session.get(url)"
}

# Composition edges
MarkdownNode[async-intro] --child_of { position: "a0" }--> Concept[AsyncIO]
CodeBlock[async-example] --child_of { position: "a1" }--> Concept[AsyncIO]

# Semantic edge
CodeBlock[async-example] --demonstrates { validated: true }--> Concept[AsyncIO]
```

---

## Appendix B: Rendering Example

Given the graph above, rendering "Async I/O" concept:

```typescript
// 1. Look up view for Concept type
const conceptView = resolveViewDefinition("system:nodetype:concept")
// Returns: ViewDefinition that queries children and renders container

// 2. Query children
const children = query(`
  MATCH (child)-[:child_of]->(parent {id: "node:concept-async-io"})
  RETURN child ORDER BY child.position
`)
// Returns: [MarkdownNode[async-intro], CodeBlock[async-example]]

// 3. Render each child
// MarkdownNode → markdown-default renderer → HTML
// CodeBlock → code-block-default renderer → highlighted HTML

// 4. Compose
<article class="concept">
  <h1>Async I/O</h1>
  <div class="markdown-content">
    <h1>Understanding Async I/O</h1>
    <p>Async I/O enables <strong>concurrent operations</strong>...</p>
  </div>
  <pre class="code-block language-python">
    async def fetch(url):
        ...
  </pre>
</article>
```

---

## Appendix C: Open Questions

These items require further design work:

1. **WikiLink syntax details:** Exact format for referencing nodes by UUID vs. by name lookup
2. **Tree structure semantics:** How deeply nested child_of relationships should work (Google Docs-style nested blocks)
3. **Query view nodes:** Detailed design for nodes that render query results inline
4. **Dashboard nodes:** Composition of multiple query views into dashboard layouts
5. **WASM binding interface:** Exact API contract for WASM renderers and extensions
6. **Performance:** Caching strategy for view resolution and rendered output

---

*This document is the canonical reference for Canopy's architecture. It will evolve as implementation proceeds and decisions are validated.*
